package configs

import (
	"celer/pkgs/dirs"
	"celer/pkgs/expr"
	"celer/pkgs/fileio"
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"slices"
	"strings"
)

func (c *Celer) GenerateToolchainFile() error {
	// Placeholder variables.
	c.variables.Inflat(c)

	var toolchain strings.Builder
	toolchain.WriteString("# ========= WARNING: This toolchain file is generated by celer. ========= #\n")

	fmt.Fprintf(&toolchain, "\n# Workspace root dir.\n")
	fmt.Fprintf(&toolchain, `get_filename_component(CELER_ROOT "${CMAKE_CURRENT_LIST_FILE}" PATH)`+"\n")

	// Set CMAKE_PREFIX_PATH before setting CMAKE_SYSROOT to locate libraries of dependencies FIRST (before sysroot)
	installedDir := c.InstalledDir(true)
	fmt.Fprintf(&toolchain, "\n# Dependency search paths.\n")
	fmt.Fprintf(&toolchain, "list(APPEND CMAKE_PREFIX_PATH %q)\n", c.InstalledDir(true))

	// Set PATH: add dev bin first.
	fmt.Fprintf(&toolchain, `set(ENV{PATH} "%s%s$ENV{PATH}")`+"\n", c.InstalledDevDir(true)+"/bin", string(os.PathListSeparator))

	// CUDA compiler configuration - MUST be set before toolchain to ensure CMake picks it up during compiler detection.
	c.writeCUDAConfig(&toolchain, installedDir)

	// Toolchain related.
	if err := c.platform.Toolchain.generate(&toolchain); err != nil {
		return err
	}

	// Rootfs related.
	rootfs := c.RootFS()
	if rootfs != nil {
		if err := rootfs.Generate(&toolchain); err != nil {
			return err
		}
	}

	// Write pkg config.
	c.writePkgConfig(&toolchain)

	// Set CMAKE_FIND_ROOT_PATH.
	var rootpaths = []string{installedDir}
	if c.RootFS() != nil {
		rootpaths = append(rootpaths, "${CMAKE_SYSROOT}")
	}
	fmt.Fprintf(&toolchain, "\n# Package search root paths.\n")
	fmt.Fprintf(&toolchain, "if(DEFINED CMAKE_FIND_ROOT_PATH)\n")
	fmt.Fprintf(&toolchain, `    set(CMAKE_FIND_ROOT_PATH "${CMAKE_FIND_ROOT_PATH}")`+"\n")
	fmt.Fprintf(&toolchain, "else()\n")
	fmt.Fprintf(&toolchain, "    set(%s %q)\n", "CMAKE_FIND_ROOT_PATH", strings.Join(rootpaths, ";"))
	fmt.Fprintf(&toolchain, "endif()\n")

	// Set CCache only when enabled.
	if c.configData.CCache != nil {
		if err := c.configData.CCache.Generate(&toolchain); err != nil {
			return err
		}
	}

	// Define global cmake vars, env vars, micro vars and compile flags.
	for index, item := range c.project.Vars {
		if index == 0 {
			fmt.Fprintf(&toolchain, "\n# Global cmake vars.\n")
		}

		parts := strings.Split(item, "=")
		if len(parts) == 1 {
			fmt.Fprintf(&toolchain, `set(%s CACHE INTERNAL "defined by celer globally.")`+"\n", item)
		} else if len(parts) == 2 {
			parts[1] = c.variables.Expand(parts[1])
			fmt.Fprintf(&toolchain, `set(%s %s CACHE INTERNAL "defined by celer globally.")`+"\n", parts[0], parts[1])
		} else {
			return fmt.Errorf("invalid cmake var: %s", item)
		}
	}

	for index, item := range c.project.Envs {
		parts := strings.Split(item, "=")
		if len(parts) != 2 {
			return fmt.Errorf("invalid env var: %s", item)
		}

		if index == 0 {
			fmt.Fprintf(&toolchain, "\n# Global envs.\n")
		}
		fmt.Fprintf(&toolchain, `set(ENV{%s} "%s")`+"\n", parts[0], parts[1])
	}

	for index, item := range c.project.Macros {
		if index == 0 {
			fmt.Fprintf(&toolchain, "\n# Global macros.\n")
		}
		fmt.Fprintf(&toolchain, "add_compile_definitions(%s)\n", item)
	}

	for index, item := range c.project.Flags {
		if index == 0 {
			fmt.Fprintf(&toolchain, "\n# Global flags.\n")
		}
		fmt.Fprintf(&toolchain, "add_compile_options(%s)\n", item)
	}

	// Compile flags.
	optimize := c.Optimize("cmake", c.platform.GetToolchain().GetName())
	if optimize != nil {
		fmt.Fprintf(&toolchain, "\n# Compile flags.\n")
		fmt.Fprintf(&toolchain, "add_compile_options(\n")
		if optimize.Release != "" {
			flags := strings.Join(strings.Fields(optimize.Release), ";")
			fmt.Fprintf(&toolchain, `    "$<$<CONFIG:Release>:%s>"`+"\n", flags)
		}
		if optimize.Debug != "" {
			flags := strings.Join(strings.Fields(optimize.Debug), ";")
			fmt.Fprintf(&toolchain, `    "$<$<CONFIG:Debug>:%s>"`+"\n", flags)
		}
		if optimize.RelWithDebInfo != "" {
			flags := strings.Join(strings.Fields(optimize.RelWithDebInfo), ";")
			fmt.Fprintf(&toolchain, `    "$<$<CONFIG:RelWithDebInfo>:%s>"`+"\n", flags)
		}
		if optimize.MinSizeRel != "" {
			flags := strings.Join(strings.Fields(optimize.MinSizeRel), ";")
			fmt.Fprintf(&toolchain, `    "$<$<CONFIG:MinSizeRel>:%s>"`+"\n", flags)
		}
		if len(c.project.Flags) > 0 {
			for _, item := range c.project.Flags {
				fmt.Fprintf(&toolchain, "    %q\n", item)
			}
		}
		fmt.Fprintf(&toolchain, ")\n")
	}

	fmt.Fprintf(&toolchain, "\n")
	if strings.ToLower(c.platform.Toolchain.GetSystemName()) == "linux" {
		fmt.Fprintf(&toolchain, "set(%s %q)\n", "CMAKE_INSTALL_RPATH", `\$ORIGIN/../lib`)
	}
	fmt.Fprintf(&toolchain, "set(%-30s%s)\n", "CMAKE_EXPORT_COMPILE_COMMANDS", "ON")

	// Write toolchain file.
	toolchainPath := filepath.Join(dirs.WorkspaceDir, "toolchain_file.cmake")
	if err := os.WriteFile(toolchainPath, []byte(toolchain.String()), os.ModePerm); err != nil {
		return err
	}

	return nil
}

func (c *Celer) writePkgConfig(toolchain *strings.Builder) {
	var (
		configPaths   []string
		configLibDirs []string
		sysrootDir    string
	)

	libraryFolder := fmt.Sprintf("%s@%s@%s", c.Platform().GetName(), c.Project().GetName(), c.BuildType())
	installedDir := filepath.Join("${CELER_ROOT}/installed", libraryFolder)

	switch runtime.GOOS {
	case "windows":
		configPaths = []string{
			filepath.ToSlash(filepath.Join(installedDir, "lib", "pkgconfig")),
			filepath.ToSlash(filepath.Join(installedDir, "share", "pkgconfig")),
		}
		sysrootDir = filepath.ToSlash(installedDir)

	case "linux":
		// Target directory.
		var targetDir string
		if c.RootFS() != nil {
			// tmp/deps is a symlink in rootfs.
			sysrootDir = "${CMAKE_SYSROOT}"
			targetDir = filepath.Join(sysrootDir, "tmp", "deps", libraryFolder)

			// Prepend pkgconfig with tmp/deps directory to prioritize it.
			configPaths = []string{
				filepath.Join(targetDir, "lib", "pkgconfig"),
				filepath.Join(targetDir, "share", "pkgconfig"),
			}

			// Add rootfs pkgconfig paths to both PKG_CONFIG_LIBDIR and PKG_CONFIG_PATH.
			for _, configPath := range c.RootFS().GetPkgConfigPath() {
				configLibDirs = append(configLibDirs, filepath.Join("${CMAKE_SYSROOT}", configPath))
			}
		} else {
			sysrootDir = "${CELER_ROOT}/installed"
			targetDir = sysrootDir

			// Append pkgconfig with tmp/deps directory.
			configPaths = []string{
				filepath.Join(targetDir, "lib", "pkgconfig"),
				filepath.Join(targetDir, "share", "pkgconfig"),
			}
		}
	}

	fmt.Fprintf(toolchain, "\n# pkg-config search paths.\n")
	executablePath := fmt.Sprintf("${CELER_ROOT}/installed/%s-dev/bin/pkgconf", c.platform.GetHostName())
	fmt.Fprintf(toolchain, "set(%-30s%q)\n", "PKG_CONFIG_EXECUTABLE", executablePath)

	// PKG_CONFIG_SYSROOT_DIR
	fmt.Fprintf(toolchain, "set(%-30s%q)\n", "ENV{PKG_CONFIG_SYSROOT_DIR}", sysrootDir)

	// PKG_CONFIG_LIBDIR
	if len(configLibDirs) > 0 {
		toolchain.WriteString("set(PKG_CONFIG_LIBDIR" + "\n")
		for _, path := range configLibDirs {
			toolchain.WriteString(fmt.Sprintf(`	"%s"`, path) + "\n")
		}
		toolchain.WriteString(")\n")
		toolchain.WriteString(fmt.Sprintf(`list(JOIN PKG_CONFIG_LIBDIR "%s" PKG_CONFIG_LIBDIR_STR)`, string(os.PathListSeparator)) + "\n")
		fmt.Fprintf(toolchain, "set(%s %q)\n\n", "ENV{PKG_CONFIG_LIBDIR}", "${PKG_CONFIG_LIBDIR_STR}")
	}

	// PKG_CONFIG_PATH
	if len(configPaths) > 0 {
		toolchain.WriteString("set(PKG_CONFIG_PATH" + "\n")
		for _, path := range configPaths {
			toolchain.WriteString(fmt.Sprintf("    %q", path) + "\n")
		}
		toolchain.WriteString(")\n")
		toolchain.WriteString(fmt.Sprintf(`list(JOIN PKG_CONFIG_PATH "%s" PKG_CONFIG_PATH_STR)`, string(os.PathListSeparator)) + "\n")
		fmt.Fprintf(toolchain, "set(%s %q)\n", "ENV{PKG_CONFIG_PATH}", "${PKG_CONFIG_PATH_STR}")
	}
}

// writeCUDAConfig detects CUDA dependencies and writes CUDA compiler configuration to toolchain file.
func (c *Celer) writeCUDAConfig(toolchain *strings.Builder, installedDir string) {
	nvccName := expr.If(runtime.GOOS == "windows", "nvcc.exe", "nvcc")

	// Check if CUDA is required from project configuration.
	containsCUDA := slices.ContainsFunc(c.project.Ports, func(port string) bool {
		return strings.HasPrefix(strings.ToLower(port), "cuda")
	})

	// If not in project config, check if CUDA files exist (backward compatibility).
	if !containsCUDA {
		installedDirActual := c.InstalledDir(false)
		nvccPath := filepath.Join(installedDirActual, "bin", nvccName)
		cudaHeaderPath := filepath.Join(installedDirActual, "include", "cuda_runtime.h")
		if !fileio.PathExists(nvccPath) || !fileio.PathExists(cudaHeaderPath) {
			return
		}
	}

	// CUDA is available or will be installed, write configuration.
	cudaToolkitRoot := filepath.ToSlash(installedDir)
	installedDirCMake := c.InstalledDir(true)
	nvccCMakePath := filepath.ToSlash(filepath.Join(installedDirCMake, "bin", nvccName))

	fmt.Fprintf(toolchain, "\nif(DEFINED TMP_DEP_DIR)\n")
	fmt.Fprintf(toolchain, "    # CUDA compiler configuration.\n")
	fmt.Fprintf(toolchain, `    set(CUDA_TOOLKIT_ROOT_DIR "${TMP_DEP_DIR}" CACHE INTERNAL "CUDA Toolkit root directory.")`+"\n")
	fmt.Fprintf(toolchain, `    set(CUDAToolkit_ROOT "${TMP_DEP_DIR}" CACHE INTERNAL "CUDA Toolkit root directory.")`+"\n")
	fmt.Fprintf(toolchain, `    set(CMAKE_CUDA_COMPILER "${TMP_DEP_DIR}/bin/%s" CACHE INTERNAL "CUDA compiler" FORCE)`+"\n", nvccName)

	if runtime.GOOS == "windows" {
		fmt.Fprintf(toolchain, "\n    # Set CUDA toolset for Visual Studio generator (VS integration is in TMP_DEP_DIR).\n")
		fmt.Fprintf(toolchain, `    set(CMAKE_GENERATOR_TOOLSET "cuda=${TMP_DEP_DIR}" CACHE INTERNAL "CUDA toolset for Visual Studio generator.")`+"\n")
		fmt.Fprintf(toolchain, `    set(CMAKE_VS_PLATFORM_TOOLSET_CUDA "${TMP_DEP_DIR}" CACHE INTERNAL "CUDA toolset path for Visual Studio.")`+"\n")
	}
	fmt.Fprintf(toolchain, "else()\n")
	fmt.Fprintf(toolchain, "    # CUDA compiler configuration.\n")
	fmt.Fprintf(toolchain, "    set(CUDA_TOOLKIT_ROOT_DIR %q CACHE INTERNAL \"CUDA Toolkit root directory.\")\n", cudaToolkitRoot)
	fmt.Fprintf(toolchain, "    set(CUDAToolkit_ROOT %q CACHE INTERNAL \"CUDA Toolkit root directory.\")\n", cudaToolkitRoot)
	fmt.Fprintf(toolchain, "    set(CMAKE_CUDA_COMPILER %q CACHE INTERNAL \"CUDA compiler\" FORCE)\n", nvccCMakePath)

	if runtime.GOOS == "windows" {
		fmt.Fprintf(toolchain, "\n    # Set CUDA toolset for Visual Studio generator.\n")
		fmt.Fprintf(toolchain, "    set(CMAKE_GENERATOR_TOOLSET %q CACHE INTERNAL \"CUDA toolset for Visual Studio generator.\")\n", "cuda="+cudaToolkitRoot)
		fmt.Fprintf(toolchain, "    set(CMAKE_VS_PLATFORM_TOOLSET_CUDA %q CACHE INTERNAL \"CUDA toolset path for Visual Studio.\")\n", cudaToolkitRoot)
	}
	fmt.Fprintf(toolchain, "endif()\n")

	fmt.Fprintf(toolchain, "set(CMAKE_CUDA_FLAGS_INIT %q CACHE STRING \"CUDA compiler flags.\" FORCE)\n",
		"-Wno-deprecated-gpu-targets --forward-unknown-opts --forward-slash-prefix-opts")
}
