package configs

import (
	"celer/pkgs/dirs"
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"strings"
)

func (c *Celer) GenerateToolchainFile() error {
	var toolchain strings.Builder
	toolchain.WriteString("# ========= WARNING: This toolchain file is generated by celer. ========= #\n")

	fmt.Fprintf(&toolchain, "\n# Workspace root dir.\n")
	fmt.Fprintf(&toolchain, `get_filename_component(WORKSPACE_DIR "${CMAKE_CURRENT_LIST_FILE}" PATH)`+"\n")

	// Toolchain related.
	if err := c.platform.Toolchain.generate(&toolchain); err != nil {
		return err
	}

	// Rootfs related.
	rootfs := c.RootFS()
	if rootfs != nil {
		if err := rootfs.Generate(&toolchain); err != nil {
			return err
		}
	}

	// Write pkg config.
	c.writePkgConfig(&toolchain)

	// Set CMAKE_FIND_ROOT_PATH.
	installedDir := "${WORKSPACE_DIR}/installed/" + c.Global.Platform + "@" + c.Global.Project + "@" + c.Global.BuildType
	var rootpaths = []string{installedDir}
	if c.RootFS() != nil {
		rootpaths = append(rootpaths, "${CMAKE_SYSROOT}")
	}
	fmt.Fprintf(&toolchain, "\n# Package search root paths.\n")
	fmt.Fprintf(&toolchain, "if(DEFINED CMAKE_FIND_ROOT_PATH)\n")
	fmt.Fprintf(&toolchain, "    set(CMAKE_FIND_ROOT_PATH \"${CMAKE_FIND_ROOT_PATH}\")\n")
	fmt.Fprintf(&toolchain, "else()\n")
	fmt.Fprintf(&toolchain, "    set(%s %q)\n", "CMAKE_FIND_ROOT_PATH", strings.Join(rootpaths, ";"))
	fmt.Fprintf(&toolchain, "endif()\n")

	// Set CMAKE_PREFIX_PATH.
	fmt.Fprintf(&toolchain, "\n# Package search paths.\n")
	fmt.Fprintf(&toolchain, "list(APPEND CMAKE_PREFIX_PATH %q)\n", installedDir)

	// Set CCache only when enabled.
	if c.configData.CCache != nil {
		if err := c.configData.CCache.Generate(&toolchain); err != nil {
			return err
		}
	}

	// Define global cmake vars, env vars, micro vars and compile flags.
	for index, item := range c.project.Vars {
		if index == 0 {
			fmt.Fprintf(&toolchain, "\n# Global cmake vars.\n")
		}

		parts := strings.Split(item, "=")
		if len(parts) == 1 {
			fmt.Fprintf(&toolchain, `set(%s CACHE INTERNAL "defined by celer globally.")`+"\n", item)
		} else if len(parts) == 2 {
			fmt.Fprintf(&toolchain, `set(%s "%s" CACHE INTERNAL "defined by celer globally.")`+"\n", parts[0], parts[1])
		} else {
			return fmt.Errorf("invalid cmake var: %s", item)
		}
	}

	for index, item := range c.project.Envs {
		parts := strings.Split(item, "=")
		if len(parts) != 2 {
			return fmt.Errorf("invalid env var: %s", item)
		}

		if index == 0 {
			fmt.Fprintf(&toolchain, "\n# Global envs.\n")
		}
		fmt.Fprintf(&toolchain, `set(ENV{%s} "%s")`+"\n", parts[0], parts[1])
	}

	for index, item := range c.project.Micros {
		if index == 0 {
			fmt.Fprintf(&toolchain, "\n# Global micros.\n")
		}
		fmt.Fprintf(&toolchain, "add_compile_definitions(%s)\n", item)
	}

	optimize := c.Optimize("cmake", c.platform.GetToolchain().GetName())
	if optimize != nil {
		fmt.Fprintf(&toolchain, "\n# Compile flags.\n")
		fmt.Fprintf(&toolchain, "add_compile_options(\n")
		if optimize.Release != "" {
			flags := strings.Join(strings.Fields(optimize.Release), ";")
			fmt.Fprintf(&toolchain, "    \"$<$<CONFIG:Release>:%s>\"\n", flags)
		}
		if optimize.Debug != "" {
			flags := strings.Join(strings.Fields(optimize.Debug), ";")
			fmt.Fprintf(&toolchain, "    \"$<$<CONFIG:Debug>:%s>\"\n", flags)
		}
		if optimize.RelWithDebInfo != "" {
			flags := strings.Join(strings.Fields(optimize.RelWithDebInfo), ";")
			fmt.Fprintf(&toolchain, "    \"$<$<CONFIG:RelWithDebInfo>:%s>\"\n", flags)
		}
		if optimize.MinSizeRel != "" {
			flags := strings.Join(strings.Fields(optimize.MinSizeRel), ";")
			fmt.Fprintf(&toolchain, "    \"$<$<CONFIG:MinSizeRel>:%s>\"\n", flags)
		}
		if len(c.project.Flags) > 0 {
			for _, item := range c.project.Flags {
				fmt.Fprintf(&toolchain, "    %q\n", item)
			}
		}
		fmt.Fprintf(&toolchain, ")\n")
	}

	fmt.Fprintf(&toolchain, "\n")
	if strings.ToLower(c.platform.Toolchain.GetSystemName()) == "linux" {
		fmt.Fprintf(&toolchain, "set(%s %q)\n", "CMAKE_INSTALL_RPATH", `\$ORIGIN/../lib`)
	}
	fmt.Fprintf(&toolchain, "set(%-30s%s)\n", "CMAKE_EXPORT_COMPILE_COMMANDS", "ON")

	// Write toolchain file.
	toolchainPath := filepath.Join(dirs.WorkspaceDir, "toolchain_file.cmake")
	if err := os.WriteFile(toolchainPath, []byte(toolchain.String()), os.ModePerm); err != nil {
		return err
	}

	return nil
}

func (c *Celer) writePkgConfig(toolchain *strings.Builder) {
	var (
		configPaths   []string
		configLibDirs []string
		sysrootDir    string
	)

	libraryFolder := fmt.Sprintf("%s@%s@%s", c.Platform().GetName(), c.Project().GetName(), c.BuildType())
	installedDir := filepath.Join("${WORKSPACE_DIR}/installed", libraryFolder)

	switch runtime.GOOS {
	case "windows":
		configPaths = []string{
			filepath.ToSlash(filepath.Join(installedDir, "lib", "pkgconfig")),
			filepath.ToSlash(filepath.Join(installedDir, "share", "pkgconfig")),
		}
		sysrootDir = filepath.ToSlash(installedDir)

	case "linux":
		// Target directory.
		var targetDir string
		if c.RootFS() != nil {
			for _, configPath := range c.RootFS().GetPkgConfigPath() {
				configLibDirs = append(configLibDirs, filepath.Join("${CMAKE_SYSROOT}", configPath))
			}

			// tmpdeps is a symlink in rootfs.
			sysrootDir = "${CMAKE_SYSROOT}"
			targetDir = filepath.Join(sysrootDir, "tmp", "deps", libraryFolder)
		} else {
			sysrootDir = "${WORKSPACE_DIR}/installed"
			targetDir = sysrootDir
		}

		// Append pkgconfig with tmp/deps directory.
		configPaths = []string{
			filepath.Join(targetDir, "lib", "pkgconfig"),
			filepath.Join(targetDir, "share", "pkgconfig"),
		}
	}

	fmt.Fprintf(toolchain, "\n# pkg-config search paths.\n")
	executablePath := fmt.Sprintf("${WORKSPACE_DIR}/installed/%s-dev/bin/pkgconf", c.platform.GetHostName())
	fmt.Fprintf(toolchain, "set(%-30s%q)\n", "PKG_CONFIG_EXECUTABLE", executablePath)

	// PKG_CONFIG_SYSROOT_DIR
	fmt.Fprintf(toolchain, "set(%-30s%q)\n", "ENV{PKG_CONFIG_SYSROOT_DIR}", sysrootDir)

	// PKG_CONFIG_LIBDIR
	if len(configLibDirs) > 0 {
		toolchain.WriteString("set(PKG_CONFIG_LIBDIR" + "\n")
		for _, path := range configLibDirs {
			toolchain.WriteString(fmt.Sprintf(`	"%s"`, path) + "\n")
		}
		toolchain.WriteString(")\n")
		toolchain.WriteString(fmt.Sprintf(`list(JOIN PKG_CONFIG_LIBDIR "%s" PKG_CONFIG_LIBDIR_STR)`, string(os.PathListSeparator)) + "\n")
		fmt.Fprintf(toolchain, "set(%s %q)\n\n", "ENV{PKG_CONFIG_LIBDIR}", "${PKG_CONFIG_LIBDIR_STR}")
	}

	// PKG_CONFIG_PATH
	if len(configPaths) > 0 {
		toolchain.WriteString("set(PKG_CONFIG_PATH" + "\n")
		for _, path := range configPaths {
			toolchain.WriteString(fmt.Sprintf("    %q", path) + "\n")
		}
		toolchain.WriteString(")\n")
		toolchain.WriteString(fmt.Sprintf(`list(JOIN PKG_CONFIG_PATH "%s" PKG_CONFIG_PATH_STR)`, string(os.PathListSeparator)) + "\n")
		fmt.Fprintf(toolchain, "set(%s %q)\n", "ENV{PKG_CONFIG_PATH}", "${PKG_CONFIG_PATH_STR}")
	}
}
