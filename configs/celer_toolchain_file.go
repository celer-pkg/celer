package configs

import (
	"celer/buildtools"
	"celer/pkgs/dirs"
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"strings"
)

func (c *Celer) GenerateToolchainFile() error {
	var toolchain strings.Builder
	toolchain.WriteString("# ========= WARNING: This toolchain file is generated by celer. ========= #\n")

	// Append tool paths.
	tools, err := buildtools.AllBuildTools()
	if err != nil {
		return err
	}
	var toolPaths = []string{fmt.Sprintf("${WORKSPACE_DIR}/installed/%s-dev/bin", c.platform.GetHostName())}
	for _, tool := range tools {
		for _, path := range tool.Paths {
			toolPaths = append(toolPaths, fmt.Sprintf("${WORKSPACE_DIR}/downloads/tools/%s", path))
		}
	}
	// Append system paths.
	systemPaths := strings.SplitSeq(os.Getenv("PATH"), string(os.PathListSeparator))
	userProfile := filepath.ToSlash(os.Getenv("USERPROFILE"))
	for path := range systemPaths {
		// Replace $USERPROFILE with $ENV{USERPROFILE}
		path = filepath.ToSlash(path)
		if after, ok := strings.CutPrefix(path, userProfile); ok {
			path = filepath.Join("$ENV{USERPROFILE}", after)
			path = filepath.ToSlash(path)
		}
		toolPaths = append(toolPaths, path)
	}

	fmt.Fprintf(&toolchain, "\n# Runtime paths.\n")
	fmt.Fprintf(&toolchain, `get_filename_component(WORKSPACE_DIR "${CMAKE_CURRENT_LIST_FILE}" PATH)`+"\n")
	fmt.Fprintf(&toolchain, "set(PATH_LIST\n")
	for _, path := range toolPaths {
		fmt.Fprintf(&toolchain, "    %q\n", path)
	}
	fmt.Fprintf(&toolchain, ")\n")
	fmt.Fprintf(&toolchain, "list(JOIN PATH_LIST %q PATH_STR)\n", string(os.PathListSeparator))
	toolchain.WriteString(`set(ENV{PATH} "${PATH_STR}")` + "\n")

	// Toolchain related.
	if err := c.platform.Toolchain.generate(&toolchain); err != nil {
		return err
	}

	// Rootfs related.
	rootfs := c.RootFS()
	if rootfs != nil {
		if err := rootfs.Generate(&toolchain); err != nil {
			return err
		}
	}

	// Write pkg config.
	c.writePkgConfig(&toolchain)

	// Set CMAKE_FIND_ROOT_PATH.
	installedDir := "${WORKSPACE_DIR}/installed/" + c.Global.Platform + "@" + c.Global.Project + "@" + c.Global.BuildType
	var rootpaths = []string{installedDir}
	if c.RootFS() != nil {
		rootpaths = append(rootpaths, "${CMAKE_SYSROOT}")
	}
	toolchain.WriteString("\n# Package search root paths.\n")
	toolchain.WriteString("if(DEFINED CMAKE_FIND_ROOT_PATH)\n")
	toolchain.WriteString("    set(CMAKE_FIND_ROOT_PATH \"${CMAKE_FIND_ROOT_PATH}\")\n")
	toolchain.WriteString("else()\n")
	toolchain.WriteString(fmt.Sprintf("    set(%s %q)\n", "CMAKE_FIND_ROOT_PATH", strings.Join(rootpaths, ";")))
	toolchain.WriteString("endif()\n")

	// Set CMAKE_PREFIX_PATH.
	toolchain.WriteString("\n# Package search paths.\n")
	toolchain.WriteString(fmt.Sprintf("list(APPEND CMAKE_PREFIX_PATH %q)\n", installedDir))

	// Set CCache.
	if c.configData.CCache != nil {
		if err := c.configData.CCache.Generate(&toolchain); err != nil {
			return err
		}
	}

	// Define global cmake vars, env vars, micro vars and compile flags.
	for index, item := range c.project.Vars {
		if index == 0 {
			toolchain.WriteString("\n# Global cmake vars.\n")
		}

		parts := strings.Split(item, "=")
		if len(parts) == 1 {
			toolchain.WriteString(fmt.Sprintf(`set(%s CACHE INTERNAL "defined by celer globally.")`, item) + "\n")
		} else if len(parts) == 2 {
			toolchain.WriteString(fmt.Sprintf(`set(%s "%s" CACHE INTERNAL "defined by celer globally.")`, parts[0], parts[1]) + "\n")
		} else {
			return fmt.Errorf("invalid cmake var: %s", item)
		}
	}

	for index, item := range c.project.Envs {
		parts := strings.Split(item, "=")
		if len(parts) != 2 {
			return fmt.Errorf("invalid env var: %s", item)
		}

		if index == 0 {
			toolchain.WriteString("\n# Global envs.\n")
		}
		toolchain.WriteString(fmt.Sprintf(`set(ENV{%s} "%s")`, parts[0], parts[1]) + "\n")
	}

	for index, item := range c.project.Micros {
		if index == 0 {
			toolchain.WriteString("\n# Global micros.\n")
		}
		toolchain.WriteString(fmt.Sprintf("add_compile_definitions(%s)\n", item))
	}

	optimize := c.Optimize("cmake", c.platform.GetToolchain().GetName())
	if optimize != nil {
		toolchain.WriteString("\n# Compile flags.\n")
		toolchain.WriteString("add_compile_options(\n")
		if optimize.Release != "" {
			flags := strings.Join(strings.Fields(optimize.Release), ";")
			toolchain.WriteString(fmt.Sprintf("    \"$<$<CONFIG:Release>:%s>\"\n", flags))
		}
		if optimize.Debug != "" {
			flags := strings.Join(strings.Fields(optimize.Debug), ";")
			toolchain.WriteString(fmt.Sprintf("    \"$<$<CONFIG:Debug>:%s>\"\n", flags))
		}
		if optimize.RelWithDebInfo != "" {
			flags := strings.Join(strings.Fields(optimize.RelWithDebInfo), ";")
			toolchain.WriteString(fmt.Sprintf("    \"$<$<CONFIG:RelWithDebInfo>:%s>\"\n", flags))
		}
		if optimize.MinSizeRel != "" {
			flags := strings.Join(strings.Fields(optimize.MinSizeRel), ";")
			toolchain.WriteString(fmt.Sprintf("    \"$<$<CONFIG:MinSizeRel>:%s>\"\n", flags))
		}
		if len(c.project.Flags) > 0 {
			for _, item := range c.project.Flags {
				toolchain.WriteString(fmt.Sprintf("    %q\n", item))
			}
		}
		toolchain.WriteString(")\n")
	}

	toolchain.WriteString("\n")
	if strings.ToLower(c.platform.Toolchain.GetSystemName()) == "linux" {
		toolchain.WriteString(fmt.Sprintf("set(%s %q)\n", "CMAKE_INSTALL_RPATH", `\$ORIGIN/../lib`))
	}
	toolchain.WriteString(fmt.Sprintf("set(%-30s%s)\n", "CMAKE_EXPORT_COMPILE_COMMANDS", "ON"))

	// Write toolchain file.
	toolchainPath := filepath.Join(dirs.WorkspaceDir, "toolchain_file.cmake")
	if err := os.WriteFile(toolchainPath, []byte(toolchain.String()), os.ModePerm); err != nil {
		return err
	}

	return nil
}

func (c *Celer) writePkgConfig(toolchain *strings.Builder) {
	var (
		configPaths   []string
		configLibDirs []string
		sysrootDir    string
	)

	libraryFolder := fmt.Sprintf("%s@%s@%s", c.Platform().GetName(), c.Project().GetName(), c.BuildType())
	installedDir := filepath.Join("${WORKSPACE_DIR}/installed", libraryFolder)

	switch runtime.GOOS {
	case "windows":
		configPaths = []string{
			filepath.ToSlash(filepath.Join(installedDir, "lib", "pkgconfig")),
			filepath.ToSlash(filepath.Join(installedDir, "share", "pkgconfig")),
		}
		sysrootDir = filepath.ToSlash(installedDir)

	case "linux":
		// Target directory.
		var targetDir string
		if c.RootFS() != nil {
			for _, configPath := range c.RootFS().GetPkgConfigPath() {
				configLibDirs = append(configLibDirs, filepath.Join("${CMAKE_SYSROOT}", configPath))
			}

			// tmpdeps is a symlink in rootfs.
			sysrootDir = "${CMAKE_SYSROOT}"
			targetDir = filepath.Join(sysrootDir, "tmp", "deps", libraryFolder)
		} else {
			sysrootDir = "${WORKSPACE_DIR}/installed"
			targetDir = sysrootDir
		}

		// Append pkgconfig with tmp/deps directory.
		configPaths = []string{
			filepath.Join(targetDir, "lib", "pkgconfig"),
			filepath.Join(targetDir, "share", "pkgconfig"),
		}
	}

	fmt.Fprintf(toolchain, "\n# pkg-config search paths.\n")
	executablePath := fmt.Sprintf("${WORKSPACE_DIR}/installed/%s-dev/bin/pkgconf", c.platform.GetHostName())
	fmt.Fprintf(toolchain, "set(%-30s%q)\n", "PKG_CONFIG_EXECUTABLE", executablePath)

	// PKG_CONFIG_SYSROOT_DIR
	fmt.Fprintf(toolchain, "set(%-30s%q)\n", "ENV{PKG_CONFIG_SYSROOT_DIR}", sysrootDir)

	// PKG_CONFIG_LIBDIR
	if len(configLibDirs) > 0 {
		toolchain.WriteString("set(PKG_CONFIG_LIBDIR" + "\n")
		for _, path := range configLibDirs {
			toolchain.WriteString(fmt.Sprintf(`	"%s"`, path) + "\n")
		}
		toolchain.WriteString(")\n")
		toolchain.WriteString(fmt.Sprintf(`list(JOIN PKG_CONFIG_LIBDIR "%s" PKG_CONFIG_LIBDIR_STR)`, string(os.PathListSeparator)) + "\n")
		fmt.Fprintf(toolchain, "set(%s %q)\n\n", "ENV{PKG_CONFIG_LIBDIR}", "${PKG_CONFIG_LIBDIR_STR}")
	}

	// PKG_CONFIG_PATH
	if len(configPaths) > 0 {
		toolchain.WriteString("set(PKG_CONFIG_PATH" + "\n")
		for _, path := range configPaths {
			toolchain.WriteString(fmt.Sprintf("    %q", path) + "\n")
		}
		toolchain.WriteString(")\n")
		toolchain.WriteString(fmt.Sprintf(`list(JOIN PKG_CONFIG_PATH "%s" PKG_CONFIG_PATH_STR)`, string(os.PathListSeparator)) + "\n")
		fmt.Fprintf(toolchain, "set(%s %q)\n", "ENV{PKG_CONFIG_PATH}", "${PKG_CONFIG_PATH_STR}")
	}
}
