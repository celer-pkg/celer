package buildsystems

import (
	"celer/context"
	"celer/pkgs/cmd"
	"celer/pkgs/fileio"
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"slices"
	"strings"
)

func NewBazel(config *BuildConfig, optimize *context.Optimize) *bazel {
	return &bazel{
		BuildConfig: config,
		Optimize:    optimize,
	}
}

type bazel struct {
	*BuildConfig
	*context.Optimize
}

func (b bazel) Name() string {
	return "bazel"
}

func (b bazel) CheckTools() []string {
	b.BuildConfig.BuildTools = append(b.BuildConfig.BuildTools, "git", "bazel")
	return b.BuildConfig.BuildTools
}

func (b bazel) configured() bool {
	// Check if .bazelrc exists in BuildDir as a marker that Configure() has been run.
	bazelrcPath := filepath.Join(b.PortConfig.BuildDir, ".bazelrc")

	// Also check that at least one bazel-* symlink exists in BuildDir, indicating Bazel has been invoked.
	// Common symlinks: bazel-bin, bazel-out, bazel-testlogs, bazel-<workspace-name>
	pattern := filepath.Join(b.PortConfig.BuildDir, "bazel-*")
	matches, err := filepath.Glob(pattern)
	hasBazelSymlink := err == nil && len(matches) > 0

	return fileio.PathExists(bazelrcPath) && hasBazelSymlink
}

func (b *bazel) preConfigure() error {
	toolchain := b.Ctx.Platform().GetToolchain()

	// For MSVC build on Windows, we need to set PATH, INCLUDE and LIB env vars.
	if runtime.GOOS == "windows" {
		if toolchain != nil && (toolchain.GetName() == "msvc" || toolchain.GetName() == "clang-cl") {
			msvcEnvs, err := b.readMSVCEnvs()
			if err != nil {
				return err
			}

			os.Setenv("PATH", msvcEnvs["PATH"])
			os.Setenv("INCLUDE", msvcEnvs["INCLUDE"])
			os.Setenv("LIB", msvcEnvs["LIB"])
		}
	}

	return nil
}

func (b bazel) configureOptions() ([]string, error) {
	var options = slices.Clone(b.Options)

	// Set compilation mode based on build type.
	// Celer build types: release, debug, relwithdebinfo, minsizerel.
	// Bazel compilation modes: fastbuild, dbg, opt.
	switch b.BuildType {
	case "release", "minsizerel":
		options = append(options, "-c", "opt")
	case "debug":
		options = append(options, "-c", "dbg")
	case "relwithdebinfo":
		options = append(options, "-c", "opt", "--strip=never")
	default:
		options = append(options, "-c", "opt")
	}

	// Replace placeholders.
	for index, value := range options {
		options[index] = b.expandCommandsVariables(value)
	}

	return options, nil
}

func (b bazel) Configure(options []string) error {
	toolchain := b.Ctx.Platform().GetToolchain()
	rootfs := b.Ctx.Platform().GetRootFS()

	// Detect if this is native compilation first.
	isNative := false
	hostArch := runtime.GOARCH
	switch hostArch {
	case "amd64":
		hostArch = "x86_64"
	case "arm64":
		hostArch = "aarch64"
	}
	var targetArch string
	if toolchain != nil {
		targetArch = toolchain.GetSystemProcessor()
		if hostArch == targetArch {
			isNative = true
		}
	}

	// Determine if we should use platform/toolchain mechanism.
	// Use platform/toolchain mechanism when:
	// 1. Cross-compilation (not native), OR
	// 2. Native compilation but with rootfs (to handle external paths properly)
	usePlatformToolchain := !isNative || (isNative && rootfs != nil)

	// Set toolchain environment variables.
	// For platform/toolchain mechanism, we DON'T set environment variables
	// (they interfere with Bazel's toolchain detection)
	// For native compilation without rootfs, set environment variables as usual
	if b.DevDep && toolchain != nil && !(toolchain.GetName() == "msvc" || toolchain.GetName() == "clang-cl") {
		toolchain.ClearEnvs()
	} else if toolchain != nil && usePlatformToolchain {
		toolchain.ClearEnvs() // Use platform/toolchain mechanism, clear env vars to avoid conflicts.
	} else if toolchain != nil && !usePlatformToolchain {
		toolchain.SetEnvs(rootfs, b.Name()) // Native without rootfs: use environment variables.
	}

	// Generate Bazel platform and toolchain configurations when using platform/toolchain mechanism
	if usePlatformToolchain && toolchain != nil {
		if err := b.generateBazelCrossCompileConfig(toolchain, rootfs); err != nil {
			return fmt.Errorf("failed to generate Bazel cross-compile config: %w", err)
		}
	}

	// Generate a .bazelrc file in BuildDir to pass celer's toolchain and environment info.
	bazelrcPath := filepath.Join(b.PortConfig.BuildDir, ".bazelrc")

	var content strings.Builder
	fmt.Fprintf(&content, "# Generated by celer for port %s\n", b.PortConfig.nameVersionDesc())

	// Use BuildDir for all Bazel output to avoid polluting source directory.
	// --output_base: All build outputs go here (instead of ~/.cache/bazel)
	// --symlink_prefix: Create bazel-* symlinks in BuildDir (instead of RepoDir)
	outputBase := filepath.Join(b.PortConfig.BuildDir, "bazel-output")
	symlinkPrefix := filepath.Join(b.PortConfig.BuildDir, "bazel-")
	fmt.Fprintf(&content, "startup --output_base=%s\n", outputBase)
	fmt.Fprintf(&content, "build --symlink_prefix=%s\n", symlinkPrefix)

	// Disable bzlmod and enable WORKSPACE for compatibility with legacy projects (Bazel 8+)
	fmt.Fprintf(&content, "build --noenable_bzlmod\n")
	fmt.Fprintf(&content, "build --enable_workspace\n")

	// Note: Don't force --incompatible_enable_cc_toolchain_resolution
	// Some projects (e.g., TensorFlow) explicitly disable it in their .bazelrc
	// Let the project's own .bazelrc decide the toolchain resolution strategy

	fmt.Fprintf(&content, "build --jobs=%d\n", b.PortConfig.Jobs)

	if !b.BuildConfig.DevDep && toolchain != nil {
		if usePlatformToolchain {
			// Use platform and toolchain mechanism (for cross-compilation or native with rootfs)
			fmt.Fprintf(&content, "# Platform/toolchain configuration\n")
			fmt.Fprintf(&content, "build --platforms=//.celer_bazel/platforms:target\n")
			fmt.Fprintf(&content, "build --host_platform=//.celer_bazel/platforms:host\n")
			fmt.Fprintf(&content, "build --extra_toolchains=//.celer_bazel/toolchain:celer_toolchain\n")

			// For clang with lld, add -stdlib=libc++ flag to use libc++ standard library
			if toolchain.GetName() == "clang" && strings.Contains(toolchain.GetLD(), "lld") {
				fmt.Fprintf(&content, "build --cxxopt=-stdlib=libc++\n")
			}

			// Note: Don't enable --incompatible_enable_cc_toolchain_resolution
			// Some complex projects (like MediaPipe, TensorFlow) have their own
			// toolchain configuration that conflicts with this flag
		} else {
			// Native compilation: use environment variables (simpler)
			cc := toolchain.GetCC()
			cxx := toolchain.GetCXX()
			ar := toolchain.GetAR()
			ld := toolchain.GetLD()

			// Add ccache support if enabled.
			if b.Ctx.CCacheEnabled() {
				cc = "ccache " + cc
				cxx = "ccache " + cxx
			}

			fmt.Fprintf(&content, "build --action_env=CC=%s\n", cc)
			fmt.Fprintf(&content, "build --action_env=CXX=%s\n", cxx)
			if ar != "" {
				fmt.Fprintf(&content, "build --action_env=AR=%s\n", ar)
			}
			if ld != "" {
				fmt.Fprintf(&content, "build --action_env=LD=%s\n", ld)
			}
		}

		// Pass PATH to ensure Bazel can find the toolchain during configuration phase.
		if currentPath := os.Getenv("PATH"); currentPath != "" {
			// Quote if contains spaces
			if strings.Contains(currentPath, " ") {
				currentPath = `"` + strings.ReplaceAll(currentPath, `"`, `\"`) + `"`
			}
			fmt.Fprintf(&content, "build --action_env=PATH=%s\n", currentPath)
		}

		// Pass flags from environment (applies to both with and without rootfs).
		if cflags := os.Getenv("CFLAGS"); cflags != "" {
			// Quote if contains spaces
			quotedCflags := cflags
			if strings.Contains(cflags, " ") {
				quotedCflags = `"` + strings.ReplaceAll(cflags, `"`, `\"`) + `"`
			}
			fmt.Fprintf(&content, "build --action_env=CFLAGS=%s\n", quotedCflags)
			// Also try to pass directly to Bazel's C/C++ rules.
			for flag := range strings.FieldsSeq(cflags) {
				fmt.Fprintf(&content, "build --conlyopt=%s\n", flag)
			}
		}
		if cxxflags := os.Getenv("CXXFLAGS"); cxxflags != "" {
			// Quote if contains spaces
			quotedCxxflags := cxxflags
			if strings.Contains(cxxflags, " ") {
				quotedCxxflags = `"` + strings.ReplaceAll(cxxflags, `"`, `\"`) + `"`
			}
			fmt.Fprintf(&content, "build --action_env=CXXFLAGS=%s\n", quotedCxxflags)
			for flag := range strings.FieldsSeq(cxxflags) {
				fmt.Fprintf(&content, "build --cxxopt=%s\n", flag)
			}
		}
		if ldflags := os.Getenv("LDFLAGS"); ldflags != "" {
			// Only set LDFLAGS as environment variable.
			// Don't try to parse and pass complex linker flags as --linkopt,
			// as Bazel's options parser may not handle them correctly.
			// Projects using rules_foreign_cc or other build systems via Bazel
			// will pick up LDFLAGS from the environment.
			// Quote the value if it contains spaces to avoid parsing issues.
			if strings.Contains(ldflags, " ") {
				// Use double quotes and escape any quotes inside
				ldflags = `"` + strings.ReplaceAll(ldflags, `"`, `\"`) + `"`
			}
			fmt.Fprintf(&content, "build --action_env=LDFLAGS=%s\n", ldflags)
		}

		// On Windows with MSVC/clang-cl, pass INCLUDE and LIB paths.
		if runtime.GOOS == "windows" && (toolchain.GetName() == "msvc" || toolchain.GetName() == "clang-cl") {
			if include := os.Getenv("INCLUDE"); include != "" {
				fmt.Fprintf(&content, "build --action_env=INCLUDE=%s\n", include)
			}
			if lib := os.Getenv("LIB"); lib != "" {
				fmt.Fprintf(&content, "build --action_env=LIB=%s\n", lib)
			}
		}

		// Handle cross-compilation platforms if defined.
		// Pass target system information.
		if toolchain.GetSystemName() != "" {
			fmt.Fprintf(&content, "build --action_env=CMAKE_SYSTEM_NAME=%s\n", toolchain.GetSystemName())
		}
		if toolchain.GetSystemProcessor() != "" {
			processor := toolchain.GetSystemProcessor()
			fmt.Fprintf(&content, "build --action_env=CMAKE_SYSTEM_PROCESSOR=%s\n", processor)

			// For Bazel's native cross-compilation, we might want to set --cpu.
			// Note: This is optional and depends on the Bazel project's configuration.
			bazelCPU := b.mapToBazelCPU(processor)
			if bazelCPU != "" {
				fmt.Fprintf(&content, "build --cpu=%s\n", bazelCPU)
			}
		}
	}

	// Disable progress bar in logs to keep them clean.
	fmt.Fprintf(&content, "build --noshow_progress\n")
	fmt.Fprintf(&content, "build --verbose_failures\n")

	// Ensure the repo directory exists.
	if !fileio.PathExists(b.PortConfig.RepoDir) {
		return fmt.Errorf("repository directory does not exist: %s", b.PortConfig.RepoDir)
	}

	// Ensure BuildDir exists before writing .bazelrc.
	if err := os.MkdirAll(b.PortConfig.BuildDir, os.ModePerm); err != nil {
		return fmt.Errorf("failed to create BuildDir: %w", err)
	}

	return os.WriteFile(bazelrcPath, []byte(content.String()), os.ModePerm)
}

func (b bazel) buildOptions() ([]string, error) {
	// Return options from BuildConfig (typically build targets like //tensorflow:tensorflow)
	return b.BuildConfig.Options, nil
}

func (b bazel) Build(options []string) error {
	// Ensure we're using the generated .bazelrc file in BuildDir.
	bazelrcPath := filepath.Join(b.PortConfig.BuildDir, ".bazelrc")
	if !fileio.PathExists(bazelrcPath) {
		return fmt.Errorf(".bazelrc not found in BuildDir, please run Configure first")
	}

	// Assemble command with absolute path to .bazelrc to avoid source tree pollution.
	args := []string{"--bazelrc=" + bazelrcPath, "build"}
	args = append(args, options...)

	// Heuristic: if no target (something not starting with '-') is provided, default to //...
	hasTarget := false
	for _, opt := range options {
		if !strings.HasPrefix(opt, "-") && !strings.HasPrefix(opt, "@") {
			hasTarget = true
			break
		}
	}
	if !hasTarget {
		args = append(args, "//...")
	}

	// Execute build with "bazel" command
	// The actual bazel executable is resolved via PATH (e.g., downloads/tools/bazel/bazel)
	logPath := b.getLogPath("build")
	title := fmt.Sprintf("[build %s]", b.PortConfig.nameVersionDesc())
	executor := cmd.NewExecutor(title, "bazel", args...)
	executor.SetLogPath(logPath)
	executor.SetWorkDir(b.PortConfig.RepoDir)

	// Ensure PATH includes the required tools.
	toolchain := b.Ctx.Platform().GetToolchain()
	if toolchain != nil {
		// The toolchain.SetEnvs() was already called in Configure(),
		// but we ensure PATH is still set correctly here.
		if currentPath := os.Getenv("PATH"); currentPath != "" {
			os.Setenv("PATH", currentPath)
		}
	}

	return executor.Execute()
}

func (b bazel) installOptions() ([]string, error) {
	return nil, nil
}

func (b bazel) Install(options []string) error {
	// Auto-install logic for Bazel projects.
	// Users can override this by providing custom post_install commands in port.toml.
	bazelBinDir := filepath.Join(b.PortConfig.BuildDir, "bazel-bin")
	if !fileio.PathExists(bazelBinDir) {
		// If bazel-bin doesn't exist, skip auto-install (user may provide custom install)
		return nil
	}

	// Resolve symlink if bazel-bin is a symlink
	realBazelBinDir, err := filepath.EvalSymlinks(bazelBinDir)
	if err != nil {
		return fmt.Errorf("failed to resolve bazel-bin symlink: %w", err)
	}

	packageDir := b.PortConfig.PackageDir
	if packageDir == "" {
		return fmt.Errorf("package directory not set")
	}

	// Create standard directories
	libDir := filepath.Join(packageDir, "lib")
	includeDir := filepath.Join(packageDir, "include")
	binDir := filepath.Join(packageDir, "bin")

	if err := os.MkdirAll(libDir, os.ModePerm); err != nil {
		return fmt.Errorf("failed to create lib directory: %w", err)
	}
	if err := os.MkdirAll(includeDir, os.ModePerm); err != nil {
		return fmt.Errorf("failed to create include directory: %w", err)
	}

	// Install libraries (.a, .so, .dylib, .dll, .lib)
	if err := b.installLibraries(realBazelBinDir, libDir); err != nil {
		return fmt.Errorf("failed to install libraries: %w", err)
	}

	// Install executables
	if err := b.installExecutables(realBazelBinDir, binDir); err != nil {
		return fmt.Errorf("failed to install executables: %w", err)
	}

	// Install headers from _virtual_includes
	virtualIncludeDir := filepath.Join(realBazelBinDir, "_virtual_includes")
	if fileio.PathExists(virtualIncludeDir) {
		if err := b.installHeaders(virtualIncludeDir, includeDir); err != nil {
			return fmt.Errorf("failed to install headers: %w", err)
		}
	}

	return nil
}

// installLibraries installs library files from bazel-bin to lib directory
func (b bazel) installLibraries(bazelBinDir, libDir string) error {
	libExtensions := []string{".a", ".so", ".dylib", ".dll", ".lib"}

	return filepath.Walk(bazelBinDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			return nil
		}

		// Skip internal files
		if strings.HasSuffix(info.Name(), ".params") || strings.HasSuffix(info.Name(), ".runfiles_manifest") {
			return nil
		}

		// Skip if it's in a subdirectory we should ignore (like _objs, _solib)
		if strings.Contains(path, "/_objs/") || strings.Contains(path, "/_solib/") {
			return nil
		}

		// Check if file has a library extension
		name := info.Name()
		isLibrary := false
		for _, ext := range libExtensions {
			// Match: libxxx.so, libxxx.so.1, libxxx.a, xxx.dll, xxx.lib
			if strings.HasSuffix(name, ext) || strings.Contains(name, ext+".") {
				isLibrary = true
				break
			}
		}

		if isLibrary {
			// Copy to lib directory
			destPath := filepath.Join(libDir, name)
			if err := fileio.CopyFile(path, destPath); err != nil {
				return fmt.Errorf("failed to copy %s: %w", path, err)
			}
			fmt.Printf("Installed library: %s\n", name)
		}

		return nil
	})
}

// installExecutables installs executable files from bazel-bin to bin directory
func (b bazel) installExecutables(bazelBinDir, binDir string) error {
	installedAny := false

	err := filepath.Walk(bazelBinDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			return nil
		}

		name := info.Name()

		// Skip header files (they're not executables even if they have +x)
		if strings.HasSuffix(name, ".h") || strings.HasSuffix(name, ".hpp") ||
			strings.HasSuffix(name, ".hh") || strings.HasSuffix(name, ".hxx") {
			return nil
		}

		// Check if file is executable and not a library or object file
		if info.Mode()&0111 != 0 && !strings.HasSuffix(name, ".so") &&
			!strings.HasSuffix(name, ".a") && !strings.HasSuffix(name, ".o") &&
			!strings.HasSuffix(name, ".dylib") && !strings.HasSuffix(name, ".dll") &&
			!strings.Contains(name, ".so.") {

			// Skip internal build files
			if strings.HasPrefix(name, ".") || strings.Contains(path, "/_objs/") ||
				strings.HasSuffix(name, ".params") || strings.HasSuffix(name, ".runfiles_manifest") {
				return nil
			}

			// Only create bin directory if we actually have executables to install
			if !installedAny {
				if err := os.MkdirAll(binDir, os.ModePerm); err != nil {
					return fmt.Errorf("failed to create bin directory: %w", err)
				}
				installedAny = true
			}

			// Copy to bin directory
			destPath := filepath.Join(binDir, name)
			if err := fileio.CopyFile(path, destPath); err != nil {
				return fmt.Errorf("failed to copy %s: %w", path, err)
			}
			// Make sure it's executable
			if err := os.Chmod(destPath, 0755); err != nil {
				return fmt.Errorf("failed to chmod %s: %w", destPath, err)
			}
			fmt.Printf("Installed executable: %s\n", name)
		}
		return nil
	})

	return err
}

// installHeaders installs header files from _virtual_includes to include directory
func (b bazel) installHeaders(virtualIncludeDir, includeDir string) error {
	// _virtual_includes typically has structure: _virtual_includes/<target>/<namespace>/header.h
	// We want to preserve the namespace structure
	return filepath.Walk(virtualIncludeDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			return nil
		}

		// Check if it's a header file
		if strings.HasSuffix(info.Name(), ".h") || strings.HasSuffix(info.Name(), ".hpp") ||
			strings.HasSuffix(info.Name(), ".hh") || strings.HasSuffix(info.Name(), ".hxx") {

			// Get relative path from _virtual_includes
			relPath, err := filepath.Rel(virtualIncludeDir, path)
			if err != nil {
				return err
			}

			// Skip the first directory level (target name) to get namespace/header.h
			parts := strings.Split(relPath, string(filepath.Separator))
			if len(parts) < 2 {
				return nil
			}
			namespacePath := filepath.Join(parts[1:]...)

			// Create destination path preserving namespace
			destPath := filepath.Join(includeDir, namespacePath)
			destDir := filepath.Dir(destPath)

			if err := os.MkdirAll(destDir, os.ModePerm); err != nil {
				return fmt.Errorf("failed to create directory %s: %w", destDir, err)
			}

			// Copy or resolve symlink
			if info.Mode()&os.ModeSymlink != 0 {
				// It's a symlink, resolve and copy the actual file
				realPath, err := filepath.EvalSymlinks(path)
				if err != nil {
					return fmt.Errorf("failed to resolve symlink %s: %w", path, err)
				}
				if err := fileio.CopyFile(realPath, destPath); err != nil {
					return fmt.Errorf("failed to copy %s: %w", realPath, err)
				}
			} else {
				if err := fileio.CopyFile(path, destPath); err != nil {
					return fmt.Errorf("failed to copy %s: %w", path, err)
				}
			}
			fmt.Printf("Installed header: %s\n", namespacePath)
		}
		return nil
	})
}

func (b bazel) mapToBazelCPU(processor string) string {
	processor = strings.ToLower(processor)
	switch processor {
	case "x86_64", "amd64":
		// On Linux/Mac, Bazel uses "k8" for x86_64.
		// On Windows, it typically uses "x64_windows".
		if runtime.GOOS == "windows" {
			return "x64_windows"
		}
		return "k8"
	case "aarch64", "arm64":
		return "aarch64"
	case "armv7", "armv7l":
		return "armv7"
	case "i386", "i686", "x86":
		return "x86"
	default:
		// Return empty string if we don't have a specific mapping.
		// This allows Bazel to use its default settings.
		return ""
	}
}
