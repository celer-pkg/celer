package buildsystems

import (
	"celer/context"
	"celer/pkgs/dirs"
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"strings"
)

// bazelToolchainGenerator defines the interface for generating Bazel toolchain configurations
type bazelToolchainGenerator interface {
	// GetCompilerName returns the compiler name for Bazel config (e.g., "gcc", "clang")
	GetCompilerName() string

	// GetToolPaths returns a map of tool names to their full paths
	GetToolPaths(toolchain context.Toolchain, toolchainBinDir string) (map[string]string, error)

	// GetIncludeDirectories returns the list of include directories for this compiler
	GetIncludeDirectories(toolchain context.Toolchain, toolchainRoot, sysrootPath string, depsIncDir string) ([]string, error)
}

// generateBazelCrossCompileConfig generates Bazel platform and toolchain configurations for cross-compilation
func (b bazel) generateBazelCrossCompileConfig(toolchain context.Toolchain, rootfs context.RootFS) error {
	// Create .celer_bazel directory in repo for our custom configurations
	bazelConfigDir := filepath.Join(b.PortConfig.RepoDir, ".celer_bazel")
	if err := os.MkdirAll(bazelConfigDir, os.ModePerm); err != nil {
		return fmt.Errorf("failed to create bazel config dir: %w", err)
	}

	// Determine target constraints
	targetCPU := b.mapBazelCPUConstraint(toolchain.GetSystemProcessor())
	targetOS := b.mapBazelOSConstraint(toolchain.GetSystemName())

	// Host constraints (execution platform)
	hostCPU := b.mapBazelCPUConstraint(runtime.GOARCH)
	hostOS := b.mapBazelOSConstraint(runtime.GOOS)

	// Generate platform/BUILD file
	if err := b.generatePlatformBUILD(bazelConfigDir, hostCPU, hostOS, targetCPU, targetOS); err != nil {
		return err
	}

	// Get toolchain paths
	toolchainBinDir := toolchain.GetFullPath()
	toolchainRoot := filepath.Dir(toolchainBinDir)

	// Get sysroot path
	sysrootPath := ""
	if rootfs != nil {
		sysrootPath = rootfs.GetFullPath()
	}

	// Create the appropriate generator based on compiler type
	generator := b.createToolchainGenerator(toolchain.GetName())
	if generator == nil {
		return fmt.Errorf("unsupported compiler for Bazel cross-compilation: %s", toolchain.GetName())
	}

	// Generate toolchain/BUILD file
	if err := b.generateToolchainBUILD(bazelConfigDir, toolchain, toolchainBinDir, toolchainRoot, sysrootPath, generator); err != nil {
		return err
	}

	return nil
}

// generatePlatformBUILD generates the platforms/BUILD file
func (b bazel) generatePlatformBUILD(bazelConfigDir string, hostCPU, hostOS, targetCPU, targetOS string) error {
	platformBUILD := filepath.Join(bazelConfigDir, "platforms", "BUILD")
	if err := os.MkdirAll(filepath.Dir(platformBUILD), os.ModePerm); err != nil {
		return err
	}

	platformContent := fmt.Sprintf(`# Generated by Celer for cross-compilation

# Host platform (where build tools run)
platform(
    name = "host",
    constraint_values = [
        "%s",
        "%s",
    ],
)

# Target platform (where final binaries run)  
platform(
    name = "target",
    constraint_values = [
        "%s",
        "%s",
    ],
)
`, hostCPU, hostOS, targetCPU, targetOS)

	return os.WriteFile(platformBUILD, []byte(platformContent), 0644)
}

// generateToolchainBUILD generates the toolchain/BUILD file using the provided generator
func (b bazel) generateToolchainBUILD(bazelConfigDir string, toolchain context.Toolchain, toolchainBinDir, toolchainRoot, sysrootPath string, generator bazelToolchainGenerator) error {
	toolchainBUILD := filepath.Join(bazelConfigDir, "toolchain", "BUILD")
	if err := os.MkdirAll(filepath.Dir(toolchainBUILD), os.ModePerm); err != nil {
		return err
	}

	// Get tool paths from generator
	toolPaths, err := generator.GetToolPaths(toolchain, toolchainBinDir)
	if err != nil {
		return fmt.Errorf("failed to get tool paths: %w", err)
	}

	// Get include directories from generator
	depsIncDir := filepath.Join(dirs.TmpDepsDir, b.PortConfig.LibraryFolder, "include")
	incDirs, err := generator.GetIncludeDirectories(toolchain, toolchainRoot, sysrootPath, depsIncDir)
	if err != nil {
		return fmt.Errorf("failed to get include directories: %w", err)
	}

	// Format include directories as Bazel list
	var includeList strings.Builder
	for _, dir := range incDirs {
		fmt.Fprintf(&includeList, "\n        \"%s\",", dir)
	}

	// Format tool paths for Bazel config
	var toolPathsStr strings.Builder
	for toolName, toolPath := range toolPaths {
		toolPathsStr.WriteString(fmt.Sprintf("\n        \"%s\": \"%s\",", toolName, toolPath))
	}

	toolchainContent := fmt.Sprintf(`# Generated by Celer for cross-compilation
load("@bazel_tools//tools/cpp:unix_cc_toolchain_config.bzl", "cc_toolchain_config")

package(default_visibility = ["//visibility:public"])

filegroup(name = "empty")

cc_toolchain_config(
    name = "celer_cc_toolchain_config",
    cpu = "%s",
    compiler = "%s",
    toolchain_identifier = "celer-cross-toolchain",
    host_system_name = "local",
    target_system_name = "%s",
    target_libc = "glibc",
    abi_version = "local",
    abi_libc_version = "local",
    tool_paths = {%s
    },
    cxx_builtin_include_directories = [%s
    ],
    builtin_sysroot = "%s",
)

cc_toolchain(
    name = "celer_cc_toolchain",
    all_files = ":empty",
    compiler_files = ":empty",
    dwp_files = ":empty",
    linker_files = ":empty",
    objcopy_files = ":empty",
    strip_files = ":empty",
    supports_param_files = 1,
    toolchain_config = ":celer_cc_toolchain_config",
    toolchain_identifier = "celer-cross-toolchain",
)

toolchain(
    name = "celer_toolchain",
    exec_compatible_with = [
        "%s",
        "%s",
    ],
    target_compatible_with = [
        "%s",
        "%s",
    ],
    toolchain = ":celer_cc_toolchain",
    toolchain_type = "@bazel_tools//tools/cpp:toolchain_type",
)
`,
		toolchain.GetSystemProcessor(),
		generator.GetCompilerName(),
		toolchain.GetSystemName(),
		toolPathsStr.String(),
		includeList.String(),
		sysrootPath,
		b.mapBazelCPUConstraint(runtime.GOARCH),
		b.mapBazelOSConstraint(runtime.GOOS),
		b.mapBazelCPUConstraint(toolchain.GetSystemProcessor()),
		b.mapBazelOSConstraint(toolchain.GetSystemName()),
	)

	return os.WriteFile(toolchainBUILD, []byte(toolchainContent), os.ModePerm)
}

// createToolchainGenerator creates the appropriate generator based on compiler name
func (b bazel) createToolchainGenerator(compilerName string) bazelToolchainGenerator {
	switch compilerName {
	case "gcc":
		return &bazelGCCGenerator{}
	case "clang":
		return &bazelClangGenerator{}
	case "msvc", "clang-cl":
		// MSVC/clang-cl on Windows use msvc_cc_toolchain_config (different mechanism)
		// This function is for Unix-like cross-compilation
		return nil
	default:
		return nil
	}
}

// mapBazelCPUConstraint maps architecture to Bazel CPU constraint
func (b bazel) mapBazelCPUConstraint(arch string) string {
	arch = strings.ToLower(arch)
	switch arch {
	case "x86_64", "amd64":
		return "@platforms//cpu:x86_64"
	case "aarch64", "arm64":
		return "@platforms//cpu:aarch64"
	case "armv7", "armv7l":
		return "@platforms//cpu:arm"
	case "i386", "i686", "x86":
		return "@platforms//cpu:x86_32"
	default:
		return "@platforms//cpu:x86_64"
	}
}

// mapBazelOSConstraint maps OS name to Bazel OS constraint
func (b bazel) mapBazelOSConstraint(osName string) string {
	osName = strings.ToLower(osName)
	switch osName {
	case "linux":
		return "@platforms//os:linux"
	case "windows":
		return "@platforms//os:windows"
	case "darwin", "macos":
		return "@platforms//os:osx"
	default:
		return "@platforms//os:linux"
	}
}
