# 为什么选择 Celer？

> *解决 C/C++ 依赖管理中的难题*

你可能已经熟悉一些流行的 C/C++ 包管理工具，如 **Conan**、**Vcpkg** 和 **XMake**。这些工具在包管理方面取得了显著进展，并持续快速发展。然而，在实际的企业级开发中，仍然存在一些未解决的关键挑战：

## 🎯 Celer 解决的问题

### 1. 📦 简化库集成流程

**问题描述：**  
使用现有的三方库很简单，但添加新库却很复杂。开发者需要：

- 学习专有的脚本语言或 API
- 手动处理构建流程（configure/build/install等）
- 为每个库编写复杂的配方文件

**Celer 的解决方案：**  
只需在简单的 TOML 配置中声明构建系统类型（CMake、Make、Meson 等），你只需关注编译选项和依赖关系，Celer 会自动处理其余部分——无需深入构建系统细节。

### 2. 🏢 项目级依赖隔离

**问题描述：**  
三方库提供了众多可选功能，不同项目往往需要：

- 不同的配置组合（有时相互排斥）
- 自定义构建以避免依赖膨胀
- 将私有/内部库与公共库集成

>传统做法可能是为不同的项目提前预编译好所需要的库到一个特定目录隔离，后期库需要变化再独立编译更新，这是典型的管理编译产物方式。

**Celer 的解决方案：**  
根据不同项目的需要对三方库默认的编译配置进行重载，不同完全隔离。每个项目维护自己的：

- 库版本和构建选项
- 项目特定目录中的私有库定义
- 无全局冲突，无交叉污染

### 3. 🔗 平台多子工程管理

**问题描述：**  
平台型项目包含多个子项目时面临：

- 子项目间依赖清单分散
- 随时间推移出现版本漂移和不一致
- 人工验证成本高
- 依赖更新时难以同步

**Celer 的解决方案：**  
通过单一项目 TOML 文件进行集中式依赖控制：

1. **一次定义**：在一个地方声明所有依赖
2. **自动生成**：Celer 创建全局 `toolchain_file.cmake`
3. **处处继承**：子项目自动获得一致的依赖
4. **无缝更新**：修改project的toml配置，做到`toolchain_file.cmake`的修改，所有子项目自动同步

这既保持了子项目的独立性，又确保了整个平台的依赖一致性。

### 4. ⚡ 智能哈希缓存

**问题描述：**  
C/C++ 构建速度臭名昭著，尤其是包含多层依赖的初始构建，传统的预编译解决方案：

- 多平台依赖的三方库全靠手工编译和维护
- 依赖变化时需要手工重新编译
- git仓库存储会滚雪球，clone及慢，甚至失败
- 压缩包存档管理有会因为个别少量更新导致完整备份，显得浪费

**Celer 的解决方案：**  
精确的基于哈希的制品缓存：

- **智能 Key**：根据环境、编译器选项、依赖链等生成哈希
- **自动失效**：任何变化触发生成新哈希——无过时构建
- **共享缓存**：通过网络文件夹在团队间共享制品
- **零冗余**：相同配置从不重复构建

结果：显著减少构建时间，同时消除手动缓存管理的风险。

### 5. 🔍 自动冲突检测

**问题描述：**  
深层依赖树产生版本冲突：

- 难以发现，直到运行时失败
- 手动调试和解决痛苦
- 菱形依赖问题

**Celer 的解决方案：**  
构建时自动冲突检测：

- **基于清单**：所有依赖显式跟踪
- **版本一致性检查**：自动验证整个依赖树
- **清晰报告**：立即报告冲突，并提供可操作的详细信息
- **构建时安全**：在问题进入生产前捕获

### 6. 🤝 无缝跨公司/团队协作

**问题描述：**  
与外部合作伙伴协作时：

- 主导公司必须分发完整的构建环境
- 合作方不应需要手动安装或配置
- 工具链设置应可移植且自包含
- 编译环境一致性至关重要

**Celer 的解决方案：**  
可移植、自包含的 `toolchain_file.cmake`：

- **相对路径**：所有工具和依赖通过相对路径定位
- **单文件集成**：合作方只需设置 `CMAKE_TOOLCHAIN_FILE`
- **无需安装**：完整环境随工具链文件一起分发
- **即刻高效**：克隆、指向工具链文件、构建即刻完成

---

## 📊 快速对比

| 功能 | 传统工具 | Celer |
|---------|------------------|-------|
| **添加库** | 编写复杂配方 | 声明构建系统类型 |
| **项目隔离** | 全局配置（冲突） | 项目级隔离 |
| **多项目同步** | 手动逐项目设置 | 单一 TOML，自动同步 |
| **构建缓存** | git或压缩包存储 | 基于哈希的精确缓存 |
| **冲突检测** | 运行时发现 | 构建时检查 |
| **协作** | 手动环境设置 | 可移植工具链文件 |

---

## 💼 实际使用场景

### 嵌入式系统团队
*“我们支持不限数个芯片平台。Celer 的平台配置让我们可以立即切换目标，而不会污染彼此的依赖。”*

### 企业平台团队
*“我们的平台工程有多个子工程。一个项目 TOML 确保所有子工程使用相同的库版本——再也没有版本漂移。”*

### 开源贡献者
*“向 Celer 添加新库花了1分钟。用其他工具，学习他们的配方语言就得花好几个小时。”*

### 跨公司合作
*“我们的 SDK 随附工具链文件分发。合作方几分钟就能上手，而不是花好几天设置环境。”*

---

## 🚀 准备好尝试了吗？

Celer 专为以下需求的团队设计：
- ✅ 简化的交叉编译配置
- ✅ 企业级依赖管理
- ✅ 快速、可重现的构建
- ✅ 简单的库集成

[开始使用 →](./quick_start.md) | [返回 README →](../../README.md)