# 依赖冲突与环形依赖检测

> **自动检测项目中的版本冲突和环形依赖问题**

## 🎯 概述

Celer 提供了强大的依赖检测机制，能够在项目构建前自动发现并报告两类关键问题：

- 🔴 **版本冲突检测** - 同一库的不同版本在项目中共存
- 🔄 **环形依赖检测** - 库之间存在循环引用关系

这些检测机制确保项目的依赖关系清晰、一致，避免构建时出现难以排查的错误。

---

## 📦 版本冲突检测

### 什么是版本冲突？

当项目中的不同依赖库引用了同一个库的不同版本时，就会产生版本冲突。这种情况可能导致：
- 链接错误
- 运行时崩溃
- 未定义行为

### 冲突检测时机

Celer 会在以下操作时自动进行版本冲突检测：
- 执行 `celer install` 安装包时
- 执行 `celer tree` 查看依赖树时
- 执行 `celer reverse` 反向查看依赖时
- 执行 `celer deploy` 项目部署时

### 冲突报告示例

当检测到版本冲突时，Celer 会输出详细的冲突信息：

```
[✘] failed to check circular dependency and version conflict.
[☛] conflicting versions of ports detected:
--> ffmpeg@5.1.6 is defined in opencv@4.11.0, ffmpeg@3.4.13 is defined in project_xxx.
```

**报告解读：**
`ffmpeg` 库存在两个版本（5.1.6 和 3.4.13）同时被项目引用，一个定义被opencv@4.11.0依赖着，一个被根项目依赖着。

---

## 🔄 环形依赖检测

### 什么是环形依赖？

环形依赖（循环依赖）是指库之间形成闭环的依赖关系：
- A 依赖 B
- B 依赖 C
- C 又依赖 A

这种循环引用会导致：
- 无法确定正确的构建顺序
- 可能造成无限递归
- 构建系统陷入死循环

### 检测范围

Celer 会检测两种类型的环形依赖：

1. **运行时依赖环** - 普通 dependencies 之间的循环
2. **开发依赖环** - dev_dependencies 之间的循环

### 环形依赖报告示例

```
Error: circular dev_dependency detected: m4@1.4.19 -> automake@1.18 [dev] -> autoconf@2.72 [dev] -> m4@1.4.19 [dev] -> automake@1.18 [dev]
```

**报告解读：**
- `m4@1.4.19` 依赖 `automake@1.18`（开发依赖）
- `automake@1.18` 依赖 `autoconf@2.72`（开发依赖）
- `autoconf@2.72` 又依赖回 `m4@1.4.19`（开发依赖）
- 形成了闭环：m4 → automake → autoconf → m4 → automake

标记 `[dev]` 表示这是本地toolchain编译的，作为一个工具库。

---

## 🔍 检测原理

### 冲突检测算法

1. **收集依赖信息** - 遍历项目所有依赖，记录每个库的版本
2. **构建版本映射** - 创建 `库名 → [版本列表]` 的映射关系
3. **检测冲突** - 查找版本列表长度大于 1 的库
4. **生成报告** - 输出详细的冲突信息，包括来源和类型

### 环形检测算法

Celer 使用**深度优先搜索（DFS）+ 路径记录**算法：

1. **初始化** - 创建访问标记和路径栈
2. **DFS 遍历** - 从根依赖开始深度遍历
3. **路径检测** - 如果当前节点已在路径栈中，检测到环形
4. **分离检测** - 开发依赖和运行时依赖分别检测
5. **报告路径** - 输出完整的循环依赖路径

**关键特性：**
- ✅ 区分开发依赖和运行时依赖
- ✅ 支持 dev 依赖标记
- ✅ 提供完整的循环路径信息
- ✅ 高效的缓存机制避免重复检测
