# 为什么重新发明Celer

&emsp;&emsp;在C/C++包管理领域有几个比较知名的工具，如 Conan 和 Vcpkg，还有国内的XMake 等，它们都提供了相对成熟的包管理功能，而且现在都相当有规模了，重新发明Celer的原因如下：

**1. 托管三方库上手不太友好**

&emsp;&emsp;编译使用已经托管三方库使用方便，但贡献新的库很复杂——开发者需学习专用API/脚本语言，手动处理编译流程（configure/build/install），学习成本高。  
&emsp;&emsp;Celer通过抽象编译工具，配置文件只需声明构建系统（如cmake/makefiles/meson等），隐藏底层细节。聚焦核心配置后开发者仅需关注编译选项和依赖关系，大幅降低上手门槛。

**2. 多平台和多项目定制化支持较弱**

&emsp;&emsp;三方库通常提供大量可选特性，不同项目可能需要不同的配置组合，甚至存在互斥选项。开启过多选项会导致依赖链扩张，增加最终构建体积，企业级项目常依赖内部基础库，传统方案难以统一管理。  
&emsp;&emsp;Celer支持项目维度的库版本管理，避免全局配置冲突，同时支持在项目维度的目录里托管私有库。

**3. 对平台且多子工程的项目不友好**

&emsp;&emsp;平台型项目包含多个子工程时，传统方案需在每个子工程单独维护依赖清单，导致版本分散管理，难以确保统一，依赖库数量多时，人工核对成本高，迭代过程中易出现隐式版本漂移；  
&emsp;&emsp;Celer是集中式依赖控制：在项目根目录定义project配置文件，统一声明所有子工程依赖的库并集，自动生成全局**toolchain_file.cmake**，固化编译环境；子工程通过`CMAKE_TOOLCHAIN_FILE`指向统一工具链文件，编译时自动继承预定义的依赖版本和配置，消除人工干预；如此，既保持子工程独立性，又实现依赖的集中管控，支持动态更新，修改根配置后，所有子工程自动同步。

**4. 缺乏精确的缓存管理**

&emsp;&emsp;C/C++ 项目编译慢，尤其第一次完整编译项目时候，尤其当你的项目依赖很多三方库的时候。其次，传统预编译方案（如集中存放 lib/include）在多平台或依赖频繁变动时难以维护，手动替换易出错。  
&emsp;&emsp;Celer 以 Hash 值作为缓存 Key，Hash 由编译环境、选项、依赖链等综合计算生成。
变动即重编译：任何参数（如编译器版本、依赖选项）变化都会触发新 Hash，确保相同库不重复编译。最终显著减少三方库的重复编译时间，同时避免人工管理风险。

**5. 内部依赖冲突检查弱**

&emsp;&emsp;当依赖的库树层级比较深的时候，很容易遇到公共依赖的库版本不一致的情况，不容易发现， 且人工排查非常麻烦；  
&emsp;&emsp;正因为Celer采取的是源码即时编译的方式，所有的三方库几乎都是通过清单管理的，因此Celer在编译三方库的时候会自动检查依赖的版本是否一致，不一致则明确告知。

**6. 和外部公司合作开发不友好** 

&emsp;&emsp;当公司主导开发一个项目，合作公司参与开发，主导公司应该提供一切交叉编译环境和已经编译好的三方库，整个开发环境应该是开箱即用，而不是需要用户手动安装和配置环境变量。  
&emsp;&emsp;如上面**对平台多子工程的项目不友好**提到的，Celer会自动生成一个**toolchain_file.cmake**，这个文件会内会以相对路径找所有编译工具以及文件系统等，因此用户只需要在工程里将`CMAKE_TOOLCHAIN_FILE`指向此**toolchain_file.cmake**的路径即可。
